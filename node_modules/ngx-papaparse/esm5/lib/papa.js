/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Inject, Injectable, Optional } from '@angular/core';
import * as lib from 'papaparse/papaparse.min.js';
var Papa = /** @class */ (function () {
    function Papa(config) {
        this.config = config;
        this._papa = lib;
        if (!this.config) {
            this.config = {};
        }
    }
    /**
     * Parse CSV to an array
     * @param {?} csv
     * @param {?=} config
     * @return {?}
     */
    Papa.prototype.parse = /**
     * Parse CSV to an array
     * @param {?} csv
     * @param {?=} config
     * @return {?}
     */
    function (csv, config) {
        if (config) {
            if (config.worker === true) {
                if (this.config.scriptPath) {
                    this._papa.SCRIPT_PATH = this.config.scriptPath;
                }
                else {
                    throw new Error('When using workers, the workerScriptPath must be defined in global' +
                        ' papaparse configuration. See' +
                        ' https://alberthaff.dk/projects/ngx-papaparse/docs/v3/parsing-csv/using-serviceworkers' +
                        ' for more information.');
                }
            }
        }
        return this._papa.parse(csv, config);
    };
    /**
     * Convert an array into CSV
     * @param {?} data
     * @param {?=} config
     * @return {?}
     */
    Papa.prototype.unparse = /**
     * Convert an array into CSV
     * @param {?} data
     * @param {?=} config
     * @return {?}
     */
    function (data, config) {
        return this._papa.unparse(data, config);
    };
    /**
     * Set the size in bytes of each file chunk.
     * Used when streaming files obtained from the DOM that
     * exist on the local computer. Default 10 MB.
     * @param {?} value
     * @return {?}
     */
    Papa.prototype.setLocalChunkSize = /**
     * Set the size in bytes of each file chunk.
     * Used when streaming files obtained from the DOM that
     * exist on the local computer. Default 10 MB.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._papa.LocalChunkSize = value;
    };
    /**
     * Set the size in bytes of each remote file chunk.
     * Used when streaming remote files. Default 5 MB.
     * @param {?} value
     * @return {?}
     */
    Papa.prototype.setRemoteChunkSize = /**
     * Set the size in bytes of each remote file chunk.
     * Used when streaming remote files. Default 5 MB.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._papa.RemoteChunkSize = value;
    };
    /**
     * Set the delimiter used when it is left unspecified and cannot be detected automatically. Default is comma.
     * @param {?} value
     * @return {?}
     */
    Papa.prototype.setDefaultDelimiter = /**
     * Set the delimiter used when it is left unspecified and cannot be detected automatically. Default is comma.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._papa.DefaultDelimiter = value;
    };
    Object.defineProperty(Papa.prototype, "badDelimiters", {
        /**
         * An array of characters that are not allowed as delimiters.
         */
        get: /**
         * An array of characters that are not allowed as delimiters.
         * @return {?}
         */
        function () {
            return this._papa.BAD_DELIMITERS;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Papa.prototype, "recordSeperator", {
        /**
         * The true delimiter. Invisible. ASCII code 30.
         * Should be doing the job we strangely rely upon commas and tabs for.
         */
        get: /**
         * The true delimiter. Invisible. ASCII code 30.
         * Should be doing the job we strangely rely upon commas and tabs for.
         * @return {?}
         */
        function () {
            return this._papa.RECORD_SEP;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Papa.prototype, "unitSeperator", {
        /**
         * Also sometimes used as a delimiting character. ASCII code 31.
         */
        get: /**
         * Also sometimes used as a delimiting character. ASCII code 31.
         * @return {?}
         */
        function () {
            return this._papa.UNIT_SEP;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Papa.prototype, "workersSupported", {
        /**
         * Whether or not the browser supports HTML5 Web Workers.
         * If false, worker: true will have no effect.
         */
        get: /**
         * Whether or not the browser supports HTML5 Web Workers.
         * If false, worker: true will have no effect.
         * @return {?}
         */
        function () {
            return this._papa.WORKERS_SUPPORTED;
        },
        enumerable: true,
        configurable: true
    });
    Papa.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    Papa.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ['PapaParseGlobalConfig',] }] }
    ]; };
    return Papa;
}());
export { Papa };
if (false) {
    /** @type {?} */
    Papa.prototype._papa;
    /** @type {?} */
    Papa.prototype.config;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFwYS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1wYXBhcGFyc2UvIiwic291cmNlcyI6WyJsaWIvcGFwYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBSzNELE9BQU8sS0FBSyxHQUFHLE1BQU0sNEJBQTRCLENBQUM7O0lBTTlDLGNBQWlFLE1BQThCO1FBQTlCLFdBQU0sR0FBTixNQUFNLENBQXdCO3FCQUZoRixHQUFHO1FBSWQsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO1NBQ3BCO0tBQ0o7Ozs7Ozs7SUFLTSxvQkFBSzs7Ozs7O2NBQUMsR0FBZ0IsRUFBRSxNQUF3QjtRQUNuRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ1QsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUN6QixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7b0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDO2lCQUNuRDtnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDSixNQUFNLElBQUksS0FBSyxDQUFDLG9FQUFvRTt3QkFDaEYsK0JBQStCO3dCQUMvQix3RkFBd0Y7d0JBQ3hGLHdCQUF3QixDQUFDLENBQUM7aUJBQ2pDO2FBQ0o7U0FDSjtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7O0lBTWxDLHNCQUFPOzs7Ozs7Y0FBQyxJQUFJLEVBQUUsTUFBMEI7UUFDM0MsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBUXJDLGdDQUFpQjs7Ozs7OztjQUFDLEtBQWE7UUFDbEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDOzs7Ozs7OztJQU8vQixpQ0FBa0I7Ozs7OztjQUFDLEtBQWE7UUFDbkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDOzs7Ozs7O0lBTWhDLGtDQUFtQjs7Ozs7Y0FBQyxLQUFhO1FBQ3BDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDOztJQU14QyxzQkFBSSwrQkFBYTtRQUhqQjs7V0FFRzs7Ozs7UUFDSDtZQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQztTQUNwQzs7O09BQUE7SUFNRCxzQkFBSSxpQ0FBZTtRQUpuQjs7O1dBR0c7Ozs7OztRQUNIO1lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDO1NBQ2hDOzs7T0FBQTtJQUtELHNCQUFJLCtCQUFhO1FBSGpCOztXQUVHOzs7OztRQUNIO1lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO1NBQzlCOzs7T0FBQTtJQU1ELHNCQUFJLGtDQUFnQjtRQUpwQjs7O1dBR0c7Ozs7OztRQUNIO1lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUM7U0FDdkM7OztPQUFBOztnQkExRkosVUFBVTs7OztnREFJTSxRQUFRLFlBQUksTUFBTSxTQUFDLHVCQUF1Qjs7ZUFYM0Q7O1NBUWEsSUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0LCBJbmplY3RhYmxlLCBPcHRpb25hbH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BhcGFQYXJzZUdsb2JhbENvbmZpZ30gZnJvbSAnLi9pbnRlcmZhY2VzL3BhcGEtcGFyc2UtZ2xvYmFsLWNvbmZpZyc7XG5pbXBvcnQge1BhcGFQYXJzZVJlc3VsdH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BhcGEtcGFyc2UtcmVzdWx0JztcbmltcG9ydCB7UGFwYVBhcnNlQ29uZmlnfSBmcm9tICcuL2ludGVyZmFjZXMvcGFwYS1wYXJzZS1jb25maWcnO1xuaW1wb3J0IHtQYXBhVW5wYXJzZUNvbmZpZ30gZnJvbSAnLi9pbnRlcmZhY2VzL3BhcGEtdW5wYXJzZS1jb25maWcnO1xuaW1wb3J0ICogYXMgbGliIGZyb20gJ3BhcGFwYXJzZS9wYXBhcGFyc2UubWluLmpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBhcGEge1xuICAgIHB1YmxpYyBfcGFwYSA9IGxpYjtcblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoJ1BhcGFQYXJzZUdsb2JhbENvbmZpZycpIHByaXZhdGUgY29uZmlnPzogUGFwYVBhcnNlR2xvYmFsQ29uZmlnXG4gICAgKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBDU1YgdG8gYW4gYXJyYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgcGFyc2UoY3N2OiBzdHJpbmd8RmlsZSwgY29uZmlnPzogUGFwYVBhcnNlQ29uZmlnKTogUGFwYVBhcnNlUmVzdWx0IHtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53b3JrZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc2NyaXB0UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXBhLlNDUklQVF9QQVRIID0gdGhpcy5jb25maWcuc2NyaXB0UGF0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gdXNpbmcgd29ya2VycywgdGhlIHdvcmtlclNjcmlwdFBhdGggbXVzdCBiZSBkZWZpbmVkIGluIGdsb2JhbCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBwYXBhcGFyc2UgY29uZmlndXJhdGlvbi4gU2VlJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGh0dHBzOi8vYWxiZXJ0aGFmZi5kay9wcm9qZWN0cy9uZ3gtcGFwYXBhcnNlL2RvY3MvdjMvcGFyc2luZy1jc3YvdXNpbmctc2VydmljZXdvcmtlcnMnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcGEucGFyc2UoY3N2LCBjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gYXJyYXkgaW50byBDU1ZcbiAgICAgKi9cbiAgICBwdWJsaWMgdW5wYXJzZShkYXRhLCBjb25maWc/OiBQYXBhVW5wYXJzZUNvbmZpZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXBhLnVucGFyc2UoZGF0YSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpemUgaW4gYnl0ZXMgb2YgZWFjaCBmaWxlIGNodW5rLlxuICAgICAqIFVzZWQgd2hlbiBzdHJlYW1pbmcgZmlsZXMgb2J0YWluZWQgZnJvbSB0aGUgRE9NIHRoYXRcbiAgICAgKiBleGlzdCBvbiB0aGUgbG9jYWwgY29tcHV0ZXIuIERlZmF1bHQgMTAgTUIuXG4gICAgICovXG4gICAgcHVibGljIHNldExvY2FsQ2h1bmtTaXplKHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGFwYS5Mb2NhbENodW5rU2l6ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2l6ZSBpbiBieXRlcyBvZiBlYWNoIHJlbW90ZSBmaWxlIGNodW5rLlxuICAgICAqIFVzZWQgd2hlbiBzdHJlYW1pbmcgcmVtb3RlIGZpbGVzLiBEZWZhdWx0IDUgTUIuXG4gICAgICovXG4gICAgcHVibGljIHNldFJlbW90ZUNodW5rU2l6ZSh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BhcGEuUmVtb3RlQ2h1bmtTaXplID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZWxpbWl0ZXIgdXNlZCB3aGVuIGl0IGlzIGxlZnQgdW5zcGVjaWZpZWQgYW5kIGNhbm5vdCBiZSBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5LiBEZWZhdWx0IGlzIGNvbW1hLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXREZWZhdWx0RGVsaW1pdGVyKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGFwYS5EZWZhdWx0RGVsaW1pdGVyID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgYWxsb3dlZCBhcyBkZWxpbWl0ZXJzLlxuICAgICAqL1xuICAgIGdldCBiYWREZWxpbWl0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFwYS5CQURfREVMSU1JVEVSUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1ZSBkZWxpbWl0ZXIuIEludmlzaWJsZS4gQVNDSUkgY29kZSAzMC5cbiAgICAgKiBTaG91bGQgYmUgZG9pbmcgdGhlIGpvYiB3ZSBzdHJhbmdlbHkgcmVseSB1cG9uIGNvbW1hcyBhbmQgdGFicyBmb3IuXG4gICAgICovXG4gICAgZ2V0IHJlY29yZFNlcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcGEuUkVDT1JEX1NFUDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbHNvIHNvbWV0aW1lcyB1c2VkIGFzIGEgZGVsaW1pdGluZyBjaGFyYWN0ZXIuIEFTQ0lJIGNvZGUgMzEuXG4gICAgICovXG4gICAgZ2V0IHVuaXRTZXBlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXBhLlVOSVRfU0VQO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIHN1cHBvcnRzIEhUTUw1IFdlYiBXb3JrZXJzLlxuICAgICAqIElmIGZhbHNlLCB3b3JrZXI6IHRydWUgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICBnZXQgd29ya2Vyc1N1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcGEuV09SS0VSU19TVVBQT1JURUQ7XG4gICAgfVxufVxuIl19