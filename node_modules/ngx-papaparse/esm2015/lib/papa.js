/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Inject, Injectable, Optional } from '@angular/core';
import * as lib from 'papaparse/papaparse.min.js';
export class Papa {
    /**
     * @param {?=} config
     */
    constructor(config) {
        this.config = config;
        this._papa = lib;
        if (!this.config) {
            this.config = {};
        }
    }
    /**
     * Parse CSV to an array
     * @param {?} csv
     * @param {?=} config
     * @return {?}
     */
    parse(csv, config) {
        if (config) {
            if (config.worker === true) {
                if (this.config.scriptPath) {
                    this._papa.SCRIPT_PATH = this.config.scriptPath;
                }
                else {
                    throw new Error('When using workers, the workerScriptPath must be defined in global' +
                        ' papaparse configuration. See' +
                        ' https://alberthaff.dk/projects/ngx-papaparse/docs/v3/parsing-csv/using-serviceworkers' +
                        ' for more information.');
                }
            }
        }
        return this._papa.parse(csv, config);
    }
    /**
     * Convert an array into CSV
     * @param {?} data
     * @param {?=} config
     * @return {?}
     */
    unparse(data, config) {
        return this._papa.unparse(data, config);
    }
    /**
     * Set the size in bytes of each file chunk.
     * Used when streaming files obtained from the DOM that
     * exist on the local computer. Default 10 MB.
     * @param {?} value
     * @return {?}
     */
    setLocalChunkSize(value) {
        this._papa.LocalChunkSize = value;
    }
    /**
     * Set the size in bytes of each remote file chunk.
     * Used when streaming remote files. Default 5 MB.
     * @param {?} value
     * @return {?}
     */
    setRemoteChunkSize(value) {
        this._papa.RemoteChunkSize = value;
    }
    /**
     * Set the delimiter used when it is left unspecified and cannot be detected automatically. Default is comma.
     * @param {?} value
     * @return {?}
     */
    setDefaultDelimiter(value) {
        this._papa.DefaultDelimiter = value;
    }
    /**
     * An array of characters that are not allowed as delimiters.
     * @return {?}
     */
    get badDelimiters() {
        return this._papa.BAD_DELIMITERS;
    }
    /**
     * The true delimiter. Invisible. ASCII code 30.
     * Should be doing the job we strangely rely upon commas and tabs for.
     * @return {?}
     */
    get recordSeperator() {
        return this._papa.RECORD_SEP;
    }
    /**
     * Also sometimes used as a delimiting character. ASCII code 31.
     * @return {?}
     */
    get unitSeperator() {
        return this._papa.UNIT_SEP;
    }
    /**
     * Whether or not the browser supports HTML5 Web Workers.
     * If false, worker: true will have no effect.
     * @return {?}
     */
    get workersSupported() {
        return this._papa.WORKERS_SUPPORTED;
    }
}
Papa.decorators = [
    { type: Injectable },
];
/** @nocollapse */
Papa.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ['PapaParseGlobalConfig',] }] }
];
if (false) {
    /** @type {?} */
    Papa.prototype._papa;
    /** @type {?} */
    Papa.prototype.config;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFwYS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1wYXBhcGFyc2UvIiwic291cmNlcyI6WyJsaWIvcGFwYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBSzNELE9BQU8sS0FBSyxHQUFHLE1BQU0sNEJBQTRCLENBQUM7QUFHbEQsTUFBTTs7OztJQUdGLFlBQWlFLE1BQThCO1FBQTlCLFdBQU0sR0FBTixNQUFNLENBQXdCO3FCQUZoRixHQUFHO1FBSWQsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO1NBQ3BCO0tBQ0o7Ozs7Ozs7SUFLTSxLQUFLLENBQUMsR0FBZ0IsRUFBRSxNQUF3QjtRQUNuRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ1QsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUN6QixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7b0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDO2lCQUNuRDtnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDSixNQUFNLElBQUksS0FBSyxDQUFDLG9FQUFvRTt3QkFDaEYsK0JBQStCO3dCQUMvQix3RkFBd0Y7d0JBQ3hGLHdCQUF3QixDQUFDLENBQUM7aUJBQ2pDO2FBQ0o7U0FDSjtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7O0lBTWxDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsTUFBMEI7UUFDM0MsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBUXJDLGlCQUFpQixDQUFDLEtBQWE7UUFDbEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDOzs7Ozs7OztJQU8vQixrQkFBa0IsQ0FBQyxLQUFhO1FBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQzs7Ozs7OztJQU1oQyxtQkFBbUIsQ0FBQyxLQUFhO1FBQ3BDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDOzs7Ozs7SUFNeEMsSUFBSSxhQUFhO1FBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDO0tBQ3BDOzs7Ozs7SUFNRCxJQUFJLGVBQWU7UUFDZixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7S0FDaEM7Ozs7O0lBS0QsSUFBSSxhQUFhO1FBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO0tBQzlCOzs7Ozs7SUFNRCxJQUFJLGdCQUFnQjtRQUNoQixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQztLQUN2Qzs7O1lBMUZKLFVBQVU7Ozs7NENBSU0sUUFBUSxZQUFJLE1BQU0sU0FBQyx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdCwgSW5qZWN0YWJsZSwgT3B0aW9uYWx9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtQYXBhUGFyc2VHbG9iYWxDb25maWd9IGZyb20gJy4vaW50ZXJmYWNlcy9wYXBhLXBhcnNlLWdsb2JhbC1jb25maWcnO1xuaW1wb3J0IHtQYXBhUGFyc2VSZXN1bHR9IGZyb20gJy4vaW50ZXJmYWNlcy9wYXBhLXBhcnNlLXJlc3VsdCc7XG5pbXBvcnQge1BhcGFQYXJzZUNvbmZpZ30gZnJvbSAnLi9pbnRlcmZhY2VzL3BhcGEtcGFyc2UtY29uZmlnJztcbmltcG9ydCB7UGFwYVVucGFyc2VDb25maWd9IGZyb20gJy4vaW50ZXJmYWNlcy9wYXBhLXVucGFyc2UtY29uZmlnJztcbmltcG9ydCAqIGFzIGxpYiBmcm9tICdwYXBhcGFyc2UvcGFwYXBhcnNlLm1pbi5qcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQYXBhIHtcbiAgICBwdWJsaWMgX3BhcGEgPSBsaWI7XG5cbiAgICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KCdQYXBhUGFyc2VHbG9iYWxDb25maWcnKSBwcml2YXRlIGNvbmZpZz86IFBhcGFQYXJzZUdsb2JhbENvbmZpZ1xuICAgICkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgQ1NWIHRvIGFuIGFycmF5XG4gICAgICovXG4gICAgcHVibGljIHBhcnNlKGNzdjogc3RyaW5nfEZpbGUsIGNvbmZpZz86IFBhcGFQYXJzZUNvbmZpZyk6IFBhcGFQYXJzZVJlc3VsdCB7XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcud29ya2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNjcmlwdFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFwYS5TQ1JJUFRfUEFUSCA9IHRoaXMuY29uZmlnLnNjcmlwdFBhdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIHVzaW5nIHdvcmtlcnMsIHRoZSB3b3JrZXJTY3JpcHRQYXRoIG11c3QgYmUgZGVmaW5lZCBpbiBnbG9iYWwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgcGFwYXBhcnNlIGNvbmZpZ3VyYXRpb24uIFNlZScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBodHRwczovL2FsYmVydGhhZmYuZGsvcHJvamVjdHMvbmd4LXBhcGFwYXJzZS9kb2NzL3YzL3BhcnNpbmctY3N2L3VzaW5nLXNlcnZpY2V3b3JrZXJzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXBhLnBhcnNlKGNzdiwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGFycmF5IGludG8gQ1NWXG4gICAgICovXG4gICAgcHVibGljIHVucGFyc2UoZGF0YSwgY29uZmlnPzogUGFwYVVucGFyc2VDb25maWcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFwYS51bnBhcnNlKGRhdGEsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplIGluIGJ5dGVzIG9mIGVhY2ggZmlsZSBjaHVuay5cbiAgICAgKiBVc2VkIHdoZW4gc3RyZWFtaW5nIGZpbGVzIG9idGFpbmVkIGZyb20gdGhlIERPTSB0aGF0XG4gICAgICogZXhpc3Qgb24gdGhlIGxvY2FsIGNvbXB1dGVyLiBEZWZhdWx0IDEwIE1CLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRMb2NhbENodW5rU2l6ZSh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BhcGEuTG9jYWxDaHVua1NpemUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpemUgaW4gYnl0ZXMgb2YgZWFjaCByZW1vdGUgZmlsZSBjaHVuay5cbiAgICAgKiBVc2VkIHdoZW4gc3RyZWFtaW5nIHJlbW90ZSBmaWxlcy4gRGVmYXVsdCA1IE1CLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRSZW1vdGVDaHVua1NpemUodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wYXBhLlJlbW90ZUNodW5rU2l6ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGVsaW1pdGVyIHVzZWQgd2hlbiBpdCBpcyBsZWZ0IHVuc3BlY2lmaWVkIGFuZCBjYW5ub3QgYmUgZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gRGVmYXVsdCBpcyBjb21tYS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0RGVmYXVsdERlbGltaXRlcih2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BhcGEuRGVmYXVsdERlbGltaXRlciA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGFsbG93ZWQgYXMgZGVsaW1pdGVycy5cbiAgICAgKi9cbiAgICBnZXQgYmFkRGVsaW1pdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcGEuQkFEX0RFTElNSVRFUlM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRydWUgZGVsaW1pdGVyLiBJbnZpc2libGUuIEFTQ0lJIGNvZGUgMzAuXG4gICAgICogU2hvdWxkIGJlIGRvaW5nIHRoZSBqb2Igd2Ugc3RyYW5nZWx5IHJlbHkgdXBvbiBjb21tYXMgYW5kIHRhYnMgZm9yLlxuICAgICAqL1xuICAgIGdldCByZWNvcmRTZXBlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXBhLlJFQ09SRF9TRVA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxzbyBzb21ldGltZXMgdXNlZCBhcyBhIGRlbGltaXRpbmcgY2hhcmFjdGVyLiBBU0NJSSBjb2RlIDMxLlxuICAgICAqL1xuICAgIGdldCB1bml0U2VwZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFwYS5VTklUX1NFUDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyBIVE1MNSBXZWIgV29ya2Vycy5cbiAgICAgKiBJZiBmYWxzZSwgd29ya2VyOiB0cnVlIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAgICovXG4gICAgZ2V0IHdvcmtlcnNTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXBhLldPUktFUlNfU1VQUE9SVEVEO1xuICAgIH1cbn1cbiJdfQ==